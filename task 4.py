# -*- coding: utf-8 -*-
"""
Взгляните на показанный ниже
код, в котором используется цикл while и флаг found
для поиска в списке тепеней 2 занания 2, вовзевдённую в пятую степень

@author: workk
"""
# Дано
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = False
i = 0
while not found and i < len(L) :
    if 2 ** X == L[i] :
        found = True
    else:
        i = i + 1

if found:
    print('at index', i)
else:
    print(X, 'not found')
    



# Разберем вариант а)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
i = 0

while i < len(L):
    if 2 ** X == L[i]:
        print('at index', i)
        break
    i = i + 1
else:
    print(X, 'not found')


    
   
# Разберем вариант б)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5

for item in L:
    if 2 ** X == item:
        index = L.index(item)
        print('at index', index)
        break
else:
    print(X, 'not found')




# Разберем вариант в)
L = [1, 2, 4, 8, 16, 32, 64]
X = 5

if 2 ** X in L:
    index = L.index(2 ** X)
    print('at index', index)
else:
    print(X, 'not found')




# Разберем вариант г)
L = []
X = 5

for i in range(X + 1):
    L.append(2 ** i)

if 2 ** X in L:
    index = L.index(2 ** X)
    print('at index', index)
else:
    print(X, 'not found')

# Разберем вариант д)
'''
Да, это должно улучшить производительность, поскольку мы выполняем операцию возведения в квадрат в цикле, чем нагружаем процессор.
Поскольку это выражение остается неизмеенным в течение всего цикла, то мы можем просто выполнить его до цикла единственный раз и работать уже с вычисленным результатом.
'''
X = 5
result = 2 ** X
L = []

for i in range(X + 1):
    L.append(result)

if result in L:
    index = len(L) - 1  
    print('at index', index)
else:
    print(X, 'not found')





# Разберем вариант е)
X = 5
L = [2 ** i for i in range(X + 1)]

if 2 ** X in L:
    index = L.index(2 ** X)
    print(f'at index {index}')
else:
    print(f'{X} not found')

    
'''
Код явно написан с использование альетрнативной логики.
Попоробуйте оптимизировать код c использование рекомендаций, они являются не обязатальными, но помогут понять основные ошибки.
а)Сначала перепишите код с конструкцией else цикла while, чтобы избавиться от флага found и финального оператора if.
б) Затем перепишите код для использования цикла for с конструкцией else,
чтобы избавиться от явной логики индексации списка. (Подсказка: для получения индекса элемента применяйте списковый метод index — L. index (X)
возвращает смещение первого элемента X в списке L.)
в) Далее полностью устраните цикл, переписав код с использованием простого
выражения с операцией членства in. (За дополнительными сведениями обращайтесь в главу 8 или наберите для тестирования 2 in [1,2,3].)
г) Наконец примените цикл for и списковый метод append для генерации списка степеней 2 (L) вместо жесткого кодирования спискового литерала.
Ниже приведены более глубокие рассуждения.
д) Как вы думаете, улучшит ли производительность перенос выражения 2 ** X
за пределы циклов? Каким образом вы представили бы это в коде?
е)  Python содержит инструмент тар (функция, список), который также способен генерировать список степеней 2:. Каким образом можно его задать ? 
    
'''